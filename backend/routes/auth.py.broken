from fastapi import Depends

# Contract compliance imports
from ..core.response_models import ResponseBuilder, StandardAPIResponse
from ..core.exceptions import BusinessLogicException, AuthenticationException
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from sqlmodel import Session as SQLModelSession

from backend.database import sync_engine         raise BusinessLogicException(str(e))  except Exception as e:
        raise BusinessLogicException(str(e))
security = HTTPBearer()


# Synchronous version for test context
def get_current_user_sync(
    credentials: HTTPAuthorizationCredentials = Depends(security),
):
    token = credentials.credentials
    token_data = extract_user_from_token(token)
    with SQLModelSession(sync_engine) as session:
        user_service = UserService(session)
        user = user_service.get_user_by_id_sync(token_data.user_id)
        if user is None:
            raise BusinessLogicException("User not found")
        return ResponseBuilder.success(user)


import logging

# from services.email_service import generate_verification_token, send_verification_email
from datetime import timedelta
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, BackgroundTasks, Depends, HTTPException, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from sqlmodel.ext.asyncio.session import AsyncSession

from backend.auth.security import (
    create_access_token,
    create_refresh_token,
    extract_user_from_token,
    security_manager,
    verify_token,
)
from backend.auth.user_service import UserProfile, UserService
from backend.database import get_async_session
from backend.models.api_models import (
    TokenResponse,
    UserLogin,
    UserProfileResponse,
    UserRegistration,
)

router = APIRouter(tags=["Authentication"])
security = HTTPBearer()
logger = logging.getLogger(__name__)

# Move /register endpoint to the very top after router definition
print("[DEBUG] Registering /auth/register endpoint...")


@router.post("/register", response_model=TokenResponse)
async def register_user(
    user_data: UserRegistration, session: AsyncSession = Depends(get_async_session)
):
    """Register a new user"""
    logger.info("[DEBUG] Entered register_user endpoint")
    try:
        user_service = UserService(session)
        user_profile = await user_service.create_user(user_data)
        token_data = {
            "sub": user_profile.username,
            "user_id": user_profile.user_id,
            "scopes": ["user"],
        }
        access_token = create_access_token(token_data)
        refresh_token = create_refresh_token(token_data)
        user_dict = {
            "id": user_profile.user_id,
            "username": user_profile.username,
            "email": user_profile.email,
            "first_name": user_profile.first_name,
            "last_name": user_profile.last_name,
            "risk_tolerance": getattr(user_profile, "risk_tolerance", None),
            "preferred_stake": getattr(user_profile, "preferred_stake", None),
            "bookmakers": getattr(user_profile, "bookmakers", []),
        }
        return ResponseBuilder.success(TokenResponse(
            access_token=access_token,
            refresh_token=refresh_token,
            token_type="bearer",
            user=user_dict,
        ))
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error registering user: {e}")
        raise BusinessLogicException("Registration failed")


logger = logging.getLogger(__name__)
security = HTTPBearer()


async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    session: AsyncSession = Depends(get_async_session),
) -> UserProfile:
    """Get current authenticated user"""
    try:
        # Ensure session is a real AsyncSession, not a coroutine/generator
        if not isinstance(session, AsyncSession):
            # If session is a coroutine/generator, get the actual session
            session = (
                await session.__anext__() if hasattr(session, "__anext__") else session
            )
        token = credentials.credentials
        token_data = extract_user_from_token(token)
        logger.info(f"[DEBUG] get_current_user session type: {type(session)}")
        user_service = UserService(session)
        user = await user_service.get_user_by_id(token_data.user_id)
        if user is None:
            raise BusinessLogicException("User not found")
        logger.info(
            f"[DEBUG] get_current_user returning type: {type(user)} value: {user}"
        )
        return ResponseBuilder.success(user)

    except Exception as e:
        logger.error(f"Error getting current user: {e}")
        raise BusinessLogicException("Could not validate credentials")

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error registering user: {e}")
        raise BusinessLogicException("Registration failed")


@router.post("/login", response_model=TokenResponse)
async def login_user(
    login_data: UserLogin, session: AsyncSession = Depends(get_async_session)
) -> Dict[str, Any]:
    try:
        from sqlmodel import select

        from backend.auth.user_service import User, verify_password

        # Fetch user by username or email
        result = await session.exec(
            select(User).where(
                (User.username == login_data.username)
                | (User.email == login_data.username)
            )
        )
        db_user = result.first()
        if not db_user or not verify_password(
            login_data.password, db_user.hashed_password
        ):
            raise BusinessLogicException("Invalid username or password")
        # Build user profile dict
        user_dict = {
            "id": db_user.id,
            "username": db_user.username,
            "email": db_user.email,
            "first_name": db_user.first_name,
            "last_name": db_user.last_name,
            "risk_tolerance": getattr(db_user, "risk_tolerance", None),
            "preferred_stake": getattr(db_user, "preferred_stake", None),
            "bookmakers": getattr(db_user, "bookmakers", []),
        }
        token_data = {
            "sub": db_user.username,
            "user_id": db_user.id,
            "scopes": ["user"],
        }
        access_token = create_access_token(token_data)
        refresh_token = create_refresh_token(token_data)
        return ResponseBuilder.success(TokenResponse(
            access_token=access_token,
            refresh_token=refresh_token,
            token_type="bearer",
            user=user_dict,
        ))
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error logging in user: {e}")
        raise BusinessLogicException("Login failed")


@router.post("/refresh", response_model=StandardAPIResponse[Dict[str, Any]])
async def refresh_token(
    refresh_token: str, session: AsyncSession = Depends(get_async_session)
) -> TokenResponse:
    """Refresh access token using refresh token"""
    try:
        # Verify refresh token
        payload = verify_token(refresh_token, token_type="refresh")

        username = payload.get("sub")
        user_id = payload.get("user_id")

        if not username or not user_id:
            raise BusinessLogicException("Invalid refresh token")

        # Get user to ensure they still exist and are active
        user_service = UserService(session)
        user_profile = await user_service.get_user_by_id(user_id)
        if user_profile is None or not user_profile.is_active:
            raise BusinessLogicException("User not found or inactive")

        # Create new access token
        token_data = {
            "sub": username,
            "user_id": user_id,
            "scopes": payload.get("scopes", ["user"]),
        }

        new_access_token = create_access_token(token_data)

        # Convert user profile to response format
        user_dict = {
            "id": user_profile.user_id,
            "username": user_profile.username,
            "email": user_profile.email,
            "first_name": user_profile.first_name,
            "last_name": user_profile.last_name,
        }

        return ResponseBuilder.success(TokenResponse(
            access_token=new_access_token,
            refresh_token=refresh_token,  # Keep the same refresh token
            token_type="bearer",
            user=user_dict,
        ))

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error refreshing token: {e}")
        raise BusinessLogicException("Token refresh failed")


@router.get("/me", response_model=StandardAPIResponse[Dict[str, Any]])
async def get_current_user_info(
    current_user: UserProfile = Depends(get_current_user),
) -> Dict[str, Any]:
    """Get current user information"""
    try:
        return ResponseBuilder.success({
            "id": current_user.user_id,
            "username": current_user.username,
            "email": current_user.email,
            "first_name": current_user.first_name,
            "last_name": current_user.last_name,
            "risk_tolerance": getattr(current_user, "risk_tolerance", None),
            "preferred_stake": getattr(current_user, "preferred_stake", None),
            "bookmakers": getattr(current_user, "bookmakers", []),
            "is_active": getattr(current_user, "is_active", True),
            "is_verified": getattr(current_user, "is_verified", False),
            "created_at": getattr(current_user, "created_at", None),
            "last_login": getattr(current_user, "last_login", None),
        })

    except Exception as e:
        logger.error(f"Error fetching user profile: {e}")
        raise BusinessLogicException("Failed to fetch user profile")


@router.put("/api/user/profile", response_model=UserProfileResponse)
async def update_user_profile(
    profile_data: UserProfileResponse,
    current_user: UserProfile = Depends(get_current_user),
    session: AsyncSession = Depends(get_async_session),
) -> UserProfileResponse:
    """Update user profile information"""
    try:
        # Convert profile data to dict
        update_data = {
            "risk_tolerance": profile_data.risk_tolerance,
            "preferred_stake": profile_data.preferred_stake,
            "bookmakers": profile_data.bookmakers,
        }

        # Update user profile
        user_service = UserService(session)
        updated_profile = await user_service.update_user_profile(
            current_user.user_id, update_data
        )

        if updated_profile is None:
            raise BusinessLogicException("User not found")

        return ResponseBuilder.success(UserProfileResponse(
            user_id=updated_profile.user_id,
            risk_tolerance=updated_profile.risk_tolerance,
            preferred_stake=updated_profile.preferred_stake,
            bookmakers=updated_profile.bookmakers,
        ))

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error updating user profile: {e}")
        raise BusinessLogicException("Failed to update user profile")


@router.post("/change-password", response_model=StandardAPIResponse[Dict[str, Any]])
async def change_password(
    old_password: str,
    new_password: str,
    current_user: UserProfile = Depends(get_current_user),
    session: AsyncSession = Depends(get_async_session),
) -> Dict[str, str]:
    """Change user password"""
    try:
        user_service = UserService(session)
        success = await user_service.change_password(
            current_user.user_id, old_password, new_password
        )

        # Always return ResponseBuilder.success(success)
        return ResponseBuilder.success({
            "success": True,
            "message": "If this email is registered, a password reset link has been sent.",
        })
    except Exception as e:
        logger.error(f"Error in forgot_password: {e}")
        return ResponseBuilder.success({
            "success": True,
            "message": "If this email is registered, a password reset link has been sent.",
        })


@router.post("/api/auth/reset-password", response_model=StandardAPIResponse[Dict[str, Any]])
async def reset_password(
    request: Dict[str, str], session: AsyncSession = Depends(get_async_session)
):
    """
    Reset password using a valid reset token.
    """
    token = request.get("token")
    new_password = request.get("new_password")
    logger = logging.getLogger(__name__)
    if not token or not new_password:
        return ResponseBuilder.success({"success": False, "message": "Token and new password are required."})
    try:
        user_id = security_manager.verify_password_reset_token(token)
        user_service = UserService(session)
        user = await user_service.get_user_by_id(user_id)
        if not user:
            logger.warning(f"Password reset: user not found for token {token}")
            return ResponseBuilder.success({"success": False, "message": "Invalid or expired token."})
        # Hash new password and update
        hashed = security_manager.hash_password(new_password)
        await user_service.update_user_password(user_id, hashed)
        logger.info(f"Password reset successful for user: {user.email}")
        return ResponseBuilder.success({"success": True, "message": "Password has been reset successfully."})
    except Exception as e:
        logger.error(f"Error in reset_password: {e}")
        return ResponseBuilder.success({"success": False, "message": "Invalid or expired token."})


@router.post("/verify-email/", response_model=StandardAPIResponse[Dict[str, Any]])
async def verify_email(token: str, session: AsyncSession = Depends(get_async_session)):
    try:
        # Logic to verify the token and update user status
        user_service = UserService(session)
        user_id = verify_token(token)
        user = await user_service.get_user_by_id(user_id)
        if user:
            user.is_verified = True  # Update user model
            await session.commit()
            return ResponseBuilder.success({"message": "Email verified successfully"})
        raise BusinessLogicException("Invalid token")
    except Exception as e:
        raise BusinessLogicException("str(e"))

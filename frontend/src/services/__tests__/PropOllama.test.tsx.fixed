/**
 * IMPORTANT: This polyfill MUST be at the top of the file, before any imports
 * that might use framer-motion. Framer-motion uses window.matchMedia during module
 * initialization, so the polyfill must be defined before the module is imported.
 */
if (typeof window !== 'undefined' && !window.matchMedia) {
  Object.defineProperty(window, 'matchMedia', {
    writable: true,
    value: jest.fn().mockImplementation(query => ({
      matches: false,
      media: query,
      onchange: null,
      // These need to be actual functions for framer-motion
      addListener: jest.fn(function () {}), // deprecated
      removeListener: jest.fn(function () {}), // deprecated
      addEventListener: jest.fn(),
      removeEventListener: jest.fn(),
      dispatchEvent: jest.fn(),
    })),
  });
}
jest.mock('../propOllamaService', () => {
  const actual = jest.requireActual('../propOllamaService');
  const mockInstance = {
    getAvailableModels: jest.fn(function (...args) {
      console.log('[MOCK] getAvailableModels called, this:', this, 'args:', args);
      console.trace('[MOCK] getAvailableModels stack trace');
      return Promise.resolve(['test-model']);
    }),
    getPropOllamaHealth: jest.fn(() => Promise.resolve({ status: 'ok', message: 'healthy' })),
    getModelHealth: jest.fn(() => Promise.resolve({ status: 'ok' })),
    sendChatMessage: jest.fn(() =>
      Promise.resolve({
        content: 'AI response',
        confidence: 0.99,
        suggestions: [],
        model_used: 'test-model',
        response_time: 100,
        analysis_type: 'general',
      })
    ),
  };
  return {
    ...actual,
    propOllamaService: mockInstance,
    default: mockInstance,
  };
});

// All component/context imports must be after the mock is set up, so move them into each test

jest.mock('../backendDiscovery', () => {
  return {
    discoverBackend: jest.fn(() => {
      const url = 'http://localhost:8000';
      console.log('[INLINE MOCK] discoverBackend called, returning:', url);
      return Promise.resolve(url);
    }),
  };
});
jest.mock('axios');

// [DEBUG] Top of test file
console.log('[DEBUG] Top of PropOllama.test.tsx');

jest.mock('../backendDiscovery');
jest.mock('axios');
console.log('[DEBUG] Top of PropOllama.test.tsx');
// Mock matchMedia and scrollIntoView for jsdom and framer-motion requirements
const matchMediaMock = (query: string) => ({
  matches: false,
  media: query,
  onchange: null,
  addListener: jest.fn(), // deprecated
  removeListener: jest.fn(), // deprecated
  addEventListener: jest.fn(),
  removeEventListener: jest.fn(),
  dispatchEvent: jest.fn(),
});
Object.defineProperty(HTMLDivElement.prototype, 'scrollIntoView', {
  value: jest.fn(),
  writable: true,
});
if (!document.addEventListener) {
  document.addEventListener = jest.fn();
}
if (!Element.prototype.addEventListener) {
  Element.prototype.addEventListener = jest.fn();
}
if (!Element.prototype.removeEventListener) {
  Element.prototype.removeEventListener = jest.fn();
}
window.alert = jest.fn();
if (!window.addEventListener) {
  window.addEventListener = jest.fn();
}
if (!document.addEventListener) {
  document.addEventListener = jest.fn();
}
if (!Element.prototype.addEventListener) {
  Element.prototype.addEventListener = jest.fn();
}
if (!Element.prototype.removeEventListener) {
  Element.prototype.removeEventListener = jest.fn();
}
window.alert = jest.fn();

// Import React at the top of the file for JSX
import React from 'react';
import { render, screen, waitFor, fireEvent } from '@testing-library/react';

afterEach(() => {
  jest.resetAllMocks();
});

test('displays health check status', async () => {
  const PropOllama = require('../../components/user-friendly/PropOllama').default;
  const { QueryClient, QueryClientProvider } = require('@tanstack/react-query');
  const { MemoryRouter } = require('react-router-dom');
  const { _AppProvider } = require('../../contexts/AppContext');
  const { _AuthProvider } = require('../../contexts/AuthContext');
  const { _ThemeProvider } = require('../../contexts/ThemeContext');
  const CompositeProvider = ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={new QueryClient()}>
      <_AuthProvider>
        <MemoryRouter>
          <_ThemeProvider>
            <_AppProvider>{children}</_AppProvider>
          </_ThemeProvider>
        </MemoryRouter>
      </_AuthProvider>
    </QueryClientProvider>
  );
  render(
    <CompositeProvider>
      <PropOllama />
    </CompositeProvider>
  );
  const healthBtn = screen.getByRole('button', { name: /check propollama api health/i });
  fireEvent.click(healthBtn);
  await waitFor(() => {
    expect(screen.queryByText(/health check failed/i)).not.toBeInTheDocument();
  });
});

test('displays AI response for valid message', async () => {
  const { propOllamaService } = require('../propOllamaService');
  propOllamaService.getAvailableModels.mockImplementation(() => {
    console.log('[TEST] Explicit mock getAvailableModels called');
    return Promise.resolve(['test-model']);
  });
  propOllamaService.sendChatMessage.mockImplementation(() => {
    console.log('[TEST] Explicit mock sendChatMessage called');
    return Promise.resolve({
      content: 'AI response',
      confidence: 0.99,
      suggestions: [],
      model_used: 'test-model',
      response_time: 100,
      analysis_type: 'general',
    });
  });
  const PropOllama = require('../../components/user-friendly/PropOllama').default;
  const { QueryClient, QueryClientProvider } = require('@tanstack/react-query');
  const { MemoryRouter } = require('react-router-dom');
  const { _AppProvider } = require('../../contexts/AppContext');
  const { _AuthProvider } = require('../../contexts/AuthContext');
  const { _ThemeProvider } = require('../../contexts/ThemeContext');
  const CompositeProvider = ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={new QueryClient()}>
      <_AuthProvider>
        <MemoryRouter>
          <_ThemeProvider>
            <_AppProvider>{children}</_AppProvider>
          </_ThemeProvider>
        </MemoryRouter>
      </_AuthProvider>
    </QueryClientProvider>
  );
  render(
    <CompositeProvider>
      <PropOllama />
    </CompositeProvider>
  );
  // Wait for the model option to appear
  await screen.findByRole('option', { name: /test-model/i });
  const _input = screen.getByLabelText(/type your message/i) as HTMLInputElement;
  fireEvent.change(_input, { target: { value: 'hello' } });
  fireEvent.submit(_input.form!);
  // Use findAllByText to handle multiple matches
  const aiResponses = await screen.findAllByText(
    (content: any) => typeof content === 'string' && content.includes('AI response'),
    { exact: false }
  );
  expect(aiResponses.length).toBeGreaterThan(0);
  expect(aiResponses[0]).toBeInTheDocument();
});

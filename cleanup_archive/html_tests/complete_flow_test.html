<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Complete PropOllamaUnified Flow Test</title>
    <style>
      body {
        font-family: monospace;
        margin: 20px;
      }
      .pass {
        color: green;
        font-weight: bold;
      }
      .fail {
        color: red;
        font-weight: bold;
      }
      .info {
        color: blue;
      }
      pre {
        background: #f5f5f5;
        padding: 10px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <h1>Complete PropOllamaUnified Flow Test</h1>
    <div id="output"></div>

    <script>
      function log(message, type = "info") {
        const div = document.getElementById("output");
        const p = document.createElement("p");
        p.className = type;
        p.textContent = message;
        div.appendChild(p);
        console.log(message);
      }

      async function testCompleteFlow() {
        try {
          log("üöÄ Starting complete PropOllamaUnified flow test...", "info");

          // === STEP 1: Sport Activation ===
          log("\n=== STEP 1: Sport Activation ===", "info");
          const activationResponse = await fetch("/api/sports/activate/MLB", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
          });

          if (!activationResponse.ok) {
            throw new Error(
              `Sport activation failed: ${activationResponse.status}`
            );
          }

          const activationData = await activationResponse.json();
          log(`‚úÖ Sport activation: ${activationData.status}`, "pass");

          // === STEP 2: Featured Props Fetch ===
          log("\n=== STEP 2: Featured Props Fetch ===", "info");
          const propsResponse = await fetch(
            "/mlb/odds-comparison/?market_type=playerprops"
          );
          if (!propsResponse.ok) {
            throw new Error(`Props fetch failed: ${propsResponse.status}`);
          }

          const propsData = await propsResponse.json();
          const candidateProps = propsData.odds || [];
          log(`‚úÖ Fetched ${candidateProps.length} candidate props`, "pass");

          // === STEP 3: Map Props with Sport Context (THE FIX) ===
          log("\n=== STEP 3: Map Props with Sport Context ===", "info");
          const mapToFeaturedProps = (props, sport) => {
            return props.map((prop) => ({
              id:
                prop.id ||
                prop.event_id ||
                `${prop.player_name}-${prop.stat_type}`,
              player: prop.player || prop.player_name || "Unknown",
              matchup: prop.matchup || prop.event_name || "Unknown vs Unknown",
              stat: prop.stat || prop.stat_type || "Unknown",
              line: parseFloat(prop.line || prop.line_score || 0),
              overOdds: parseFloat(
                prop.overOdds || prop.over_odds || prop.value || 0
              ),
              underOdds: parseFloat(
                prop.underOdds || prop.under_odds || prop.value || 0
              ),
              confidence: parseFloat(prop.confidence || 0),
              sport: prop.sport || sport || "Unknown", // üéØ THE FIX
              gameTime:
                prop.gameTime || prop.start_time || new Date().toISOString(),
              pickType: prop.pickType || "prop",
            }));
          };

          const projections = mapToFeaturedProps(candidateProps, "MLB");
          log(
            `‚úÖ Mapped ${projections.length} projections with sport='${projections[0]?.sport}'`,
            "pass"
          );

          // === STEP 4: Enhanced Predictions (Batch) ===
          log("\n=== STEP 4: Enhanced Predictions (Batch) ===", "info");
          const batchResponse = await fetch("/api/unified/batch-predictions", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(projections.slice(0, 10)), // Test with first 10
          });

          if (!batchResponse.ok) {
            throw new Error(
              `Batch predictions failed: ${batchResponse.status}`
            );
          }

          const batchResults = await batchResponse.json();
          log(
            `‚úÖ Enhanced ${batchResults.length} projections with ML features`,
            "pass"
          );

          // === STEP 5: PropOllamaUnified Filtering Chain ===
          log("\n=== STEP 5: PropOllamaUnified Filtering Chain ===", "info");

          // 5a: Sport filtering (the critical fix)
          const selectedSport = "MLB";
          const sportFiltered = batchResults.filter(
            (p) => selectedSport === "All" || p.sport === selectedSport
          );
          log(
            `‚úÖ Sport filtering (${selectedSport}): ${batchResults.length} ‚Üí ${sportFiltered.length}`,
            sportFiltered.length > 0 ? "pass" : "fail"
          );

          // 5b: Search filtering
          const searchTerm = "";
          const searchFiltered = sportFiltered.filter(
            (p) =>
              searchTerm === "" ||
              (p.player &&
                p.player.toLowerCase().includes(searchTerm.toLowerCase())) ||
              (p.matchup &&
                p.matchup.toLowerCase().includes(searchTerm.toLowerCase()))
          );
          log(
            `‚úÖ Search filtering (empty): ${sportFiltered.length} ‚Üí ${searchFiltered.length}`,
            "pass"
          );

          // 5c: Sorting by confidence
          const sortedProjections = searchFiltered.sort(
            (a, b) => b.confidence - a.confidence
          );
          log(
            `‚úÖ Sorted by confidence: ${searchFiltered.length} props`,
            "pass"
          );

          // === STEP 6: Player Consolidation ===
          log("\n=== STEP 6: Player Consolidation ===", "info");
          const playerMap = new Map();
          sortedProjections.forEach((proj) => {
            const playerKey = `${proj.player}-${proj.matchup}`;

            if (playerMap.has(playerKey)) {
              const existingProj = playerMap.get(playerKey);
              if (!existingProj.alternativeProps) {
                existingProj.alternativeProps = [];
              }
              existingProj.alternativeProps.push({
                stat: proj.stat,
                line: proj.line,
                confidence: proj.confidence,
              });
            } else {
              playerMap.set(playerKey, {
                ...proj,
                alternativeProps: [],
              });
            }
          });

          const consolidatedProjections = Array.from(playerMap.values()).sort(
            (a, b) => {
              const aMaxConfidence = Math.max(
                a.confidence,
                ...(a.alternativeProps?.map((p) => p.confidence) || [])
              );
              const bMaxConfidence = Math.max(
                b.confidence,
                ...(b.alternativeProps?.map((p) => p.confidence) || [])
              );
              return bMaxConfidence - aMaxConfidence;
            }
          );
          log(
            `‚úÖ Player consolidation: ${sortedProjections.length} ‚Üí ${consolidatedProjections.length} player cards`,
            "pass"
          );

          // === STEP 7: Visible Projections Slice ===
          log("\n=== STEP 7: Visible Projections Slice ===", "info");
          const visiblePropsCount = 6;
          const visibleProjections = consolidatedProjections.slice(
            0,
            visiblePropsCount
          );
          log(
            `‚úÖ Visible projections: ${consolidatedProjections.length} ‚Üí ${visibleProjections.length} displayed`,
            "pass"
          );

          // === FINAL RESULT ===
          log("\n=== FINAL RESULT ===", "info");
          const success = visibleProjections.length > 0;
          log(
            `üéØ Props will display in UI: ${success ? "YES" : "NO"}`,
            success ? "pass" : "fail"
          );
          log(
            `üéØ Sport field fix: ${success ? "SUCCESS" : "FAILED"}`,
            success ? "pass" : "fail"
          );

          if (success) {
            log("\nüìã Sample visible projection:", "info");
            const sample = visibleProjections[0];
            const sampleDiv = document.createElement("pre");
            sampleDiv.textContent = JSON.stringify(
              {
                player: sample.player,
                stat: sample.stat,
                line: sample.line,
                confidence: sample.confidence,
                sport: sample.sport,
                matchup: sample.matchup,
              },
              null,
              2
            );
            document.getElementById("output").appendChild(sampleDiv);
          }

          // === TEST SUMMARY ===
          log("\n=== TEST SUMMARY ===", "info");
          log(
            `‚úÖ Original issue: Props had sport='Unknown', filtered out by sport filter`,
            "info"
          );
          log(
            `‚úÖ Root cause: EnhancedDataManager.mapToFeaturedProps defaulted to 'Unknown'`,
            "info"
          );
          log(
            `‚úÖ Fix applied: Pass sport context to mapToFeaturedProps method`,
            "info"
          );
          log(
            `‚úÖ Result: Props now have sport='MLB', pass sport filter`,
            "info"
          );
          log(
            `‚úÖ Validation: ${visibleProjections.length} props ready for UI display`,
            success ? "pass" : "fail"
          );
        } catch (error) {
          log(`‚ùå Flow test failed: ${error.message}`, "fail");
        }
      }

      // Run the complete test
      testCompleteFlow();
    </script>
  </body>
</html>

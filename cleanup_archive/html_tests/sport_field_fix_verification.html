<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sport Field Fix Verification</title>
  </head>
  <body>
    <h1>Sport Field Fix Verification</h1>
    <div id="log"></div>

    <script>
      function log(message) {
        console.log(message);
        document.getElementById("log").innerHTML += "<p>" + message + "</p>";
      }

      async function testSportFieldFix() {
        try {
          log("üöÄ Starting sport field fix verification...");

          // Step 1: Activate sport
          log("Step 1: Activating MLB sport...");
          const activationResponse = await fetch("/api/sports/activate/MLB", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
          });

          if (!activationResponse.ok) {
            throw new Error("Sport activation failed");
          }
          log("‚úÖ Sport activated successfully");

          // Step 2: Fetch raw props (what EnhancedDataManager.fetchSportsProps does)
          log("Step 2: Fetching raw props from backend...");
          const rawResponse = await fetch(
            "/mlb/odds-comparison/?market_type=playerprops"
          );
          if (!rawResponse.ok) {
            throw new Error("Props fetch failed");
          }
          const rawData = await rawResponse.json();
          const rawProps = rawData.odds || [];
          log(`‚úÖ Fetched ${rawProps.length} raw props from backend`);
          log(
            `Sample raw prop sport field: "${rawProps[0]?.sport || "MISSING"}"`
          );

          // Step 3: Simulate the new mapToFeaturedProps logic with sport context
          log("Step 3: Mapping props with sport context...");
          const mapPropsWithSport = (props, sport) => {
            return props.map((prop) => ({
              id:
                prop.id ||
                prop.event_id ||
                `${prop.player_name}-${prop.stat_type}`,
              player: prop.player || prop.player_name || "Unknown",
              matchup: prop.matchup || prop.event_name || "Unknown vs Unknown",
              stat: prop.stat || prop.stat_type || "Unknown",
              line: parseFloat(prop.line || prop.line_score || 0),
              overOdds: parseFloat(
                prop.overOdds || prop.over_odds || prop.value || 0
              ),
              underOdds: parseFloat(
                prop.underOdds || prop.under_odds || prop.value || 0
              ),
              confidence: parseFloat(prop.confidence || 0),
              sport: prop.sport || sport || "Unknown", // The fix: use sport context
              gameTime:
                prop.gameTime || prop.start_time || new Date().toISOString(),
              pickType: prop.pickType || "prop",
            }));
          };

          const mappedProps = mapPropsWithSport(rawProps, "MLB");
          log(`‚úÖ Mapped ${mappedProps.length} props with sport context`);
          log(`Sample mapped prop sport field: "${mappedProps[0]?.sport}"`);

          // Step 4: Test filtering (the critical part that was failing)
          log("Step 4: Testing sport filtering...");
          const selectedSport = "MLB";
          const filteredBySport = mappedProps.filter(
            (p) => selectedSport === "All" || p.sport === selectedSport
          );
          log(
            `‚úÖ Sport filtering: ${mappedProps.length} ‚Üí ${filteredBySport.length} props`
          );

          // Step 5: Test search filtering (empty search = all pass)
          const searchTerm = "";
          const filteredBySearch = filteredBySport.filter(
            (p) =>
              searchTerm === "" ||
              (p.player &&
                p.player.toLowerCase().includes(searchTerm.toLowerCase())) ||
              (p.matchup &&
                p.matchup.toLowerCase().includes(searchTerm.toLowerCase()))
          );
          log(
            `‚úÖ Search filtering: ${filteredBySport.length} ‚Üí ${filteredBySearch.length} props`
          );

          // Step 6: Test consolidation
          log("Step 5: Testing player consolidation...");
          const playerMap = new Map();
          filteredBySearch.forEach((proj) => {
            const playerKey = `${proj.player}-${proj.matchup}`;
            if (playerMap.has(playerKey)) {
              const existingProj = playerMap.get(playerKey);
              if (!existingProj.alternativeProps) {
                existingProj.alternativeProps = [];
              }
              existingProj.alternativeProps.push({
                stat: proj.stat,
                line: proj.line,
                confidence: proj.confidence,
              });
            } else {
              playerMap.set(playerKey, {
                ...proj,
                alternativeProps: [],
              });
            }
          });
          const consolidated = Array.from(playerMap.values());
          log(
            `‚úÖ Consolidation: ${filteredBySearch.length} ‚Üí ${consolidated.length} player cards`
          );

          // Step 6: Test final visible slice
          const visiblePropsCount = 6;
          const visible = consolidated.slice(0, visiblePropsCount);
          log(
            `‚úÖ Final visible: ${consolidated.length} ‚Üí ${visible.length} props shown`
          );

          // Final result
          log("");
          log("üéâ FINAL RESULT:");
          log(
            `‚úÖ Sport field fix: ${visible.length > 0 ? "SUCCESS" : "FAILED"}`
          );
          log(`‚úÖ Props will display: ${visible.length > 0 ? "YES" : "NO"}`);

          if (visible.length > 0) {
            log("Sample visible prop:");
            log(JSON.stringify(visible[0], null, 2));
          }
        } catch (error) {
          log(`‚ùå Error: ${error.message}`);
        }
      }

      // Run the test automatically
      testSportFieldFix();
    </script>
  </body>
</html>
